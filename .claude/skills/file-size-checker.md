# file-size-checker

## Description
文件大小强制执行专家。当用户开发新功能时，自动引导检查文件大小、评估代码量、规划拆分方案，防止文件膨胀。基于项目5000+行重构血泪教训制定。

## Trigger Keywords
- 新功能
- 添加功能
- 开发
- 实现
- add feature
- new feature
- implement

## Instructions

### 核心原则
```
规范不自动化 = 规范不存在
人工遵守规范不可靠，必须工具化执行
```

**血泪教训**：
- 2025-10-21 重构：EditRequirementModal (2229 → 442行)，ImportPreviewModal (1082 → 361行)，wsjf-sprint-planner (3102 → 534行)
- **耗时**: 8+ 小时重构工作
- **根本原因**: 规范存在但未自动化执行，开发者逐步突破红线

### 🚨 分级预警机制

```
🟢 < 200 行    安全区    正常开发
🟡 200-300 行  注意区    开始评估拆分
🟠 300-400 行  警告区    必须规划拆分方案
🔴 400-500 行  危险区    立即拆分，禁止添加新代码
❌ > 500 行    禁止区    拒绝提交（Git hook 拦截）
```

### 📐 开发新功能前强制检查清单

**每次用户提出新功能需求时，AI必须引导完成以下检查**：

```
□ 1. 估算新功能代码行数
     方法：参考类似功能 × 1.5（保守估计）

□ 2. 检查目标文件当前大小
     运行：npm run check-file-size

□ 3. 计算最终大小
     当前行数 + 预估行数 = ?

□ 4. 判断是否需要拆分
     - 如果 < 300 行：可以直接添加
     - 如果 300-400 行：建议先拆分
     - 如果 > 400 行：必须先拆分

□ 5. 创建拆分方案（如果需要）
     - 确定需要创建的 Hook 文件
     - 确定需要创建的组件文件
     - 规划代码组织结构

□ 6. 开始实现
     严格按照拆分方案执行
```

### 🎯 成功重构案例（参考）

| 组件 | 重构前 | 重构后 | 减少 | 创建文件 | 耗时 |
|------|--------|--------|------|----------|------|
| EditRequirementModal | 2229 行 | 442 行 | -80% | 5 个 | 2-3h |
| ImportPreviewModal | 1082 行 | 361 行 | -67% | 6 个 | 1-2h |
| wsjf-sprint-planner | 3102 行 | 534 行 | -83% | 8 个 | 3-4h |

**关键模式**：
1. 业务逻辑 → 提取到 Hook（优先）
2. 大段 JSX → 拆分为子组件（次要）
3. 配置/常量 → 独立文件（必须）

### ⚠️ 常见误区（必须避免）

#### 误区 1："稍后重构"
```
❌ 错误想法："现在先快速实现，等功能稳定了再重构"
✅ 正确做法："在实现功能的同时就保持代码质量"
💡 原因：所有"临时"代码都会变成永久代码，"稍后"永远不会到来
```

#### 误区 2："只超一点点"
```
❌ 错误想法："文件 520 行，只超了 20 行，应该没关系"
✅ 正确做法："500 行是红线，超过 1 行也必须重构"
💡 原因：破窗效应 - 一旦突破红线，从 520 行到 1000 行只需要几次提交
```

#### 误区 3："拆分会增加复杂度"
```
❌ 错误想法："拆分成多个文件，反而更难理解"
✅ 正确做法："适当的拆分会降低复杂度"
💡 原因：3000 行单文件 >> 10 个 300 行文件，单一职责的小文件更易维护
```

### 🛠️ 强制执行工具链

#### 1. 本地检查（开发时）
```bash
# 开发前检查
npm run check-file-size

# 提交前自动检查（Git pre-commit hook）
# 将在 scripts/pre-deploy-check.sh 中自动执行
```

#### 2. 文件大小限制
- ❌ **任何文件不得超过 500 行**（硬性规定）
- ⚠️ **超过 300 行时必须评估拆分**
- ✅ **推荐单文件保持在 200-300 行以内**

### AI工作流程

当用户提出新功能需求时：

1. **立即运行** `npm run check-file-size` 检查当前状态
2. **询问用户** 预估新功能会修改哪些文件
3. **计算** 目标文件最终大小
4. **判断** 是否需要先重构
5. **如果需要拆分**：先引导用户使用 refactoring-assistant skill
6. **如果可以直接开发**：提醒用户开发过程中注意文件大小

### 五大教训
1. ⭐⭐⭐ **规范必须自动化执行** - Git hooks + CI/CD 强制拦截
2. ⭐⭐⭐ **超过 200 行就应该警觉** - 分级预警机制（200/300/400/500）
3. ⭐⭐ **"临时"代码必须立即清理** - 所有"稍后重构"永远不会发生
4. ⭐⭐ **新功能开发前必须评估影响** - 预估代码量，提前规划拆分
5. ⭐ **重构成本远高于预防成本** - 重构8小时 vs 预防30分钟

### 相关文档
- ai-templates/REFACTORING_LESSONS_LEARNED.md - 完整经验教训
- ai-templates/FILE_SIZE_ENFORCEMENT.md - 新项目自动化实施模板
- docs/architecture-guide.md - 架构指导原则
- docs/refactoring-plan.md - 当前重构任务
